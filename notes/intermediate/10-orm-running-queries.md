# Running Queries

With SQLAlchemy, queries can be written using Python code rather than raw SQL. This simplifies database interactions and promotes maintainable code.

- Before proceeding, ensure that the following are imported and set:

```python
from sqlalchemy.orm import Session
from fastapi import Depends, FastAPI, HTTPException, status
from .database import get_db
from .models import Post
from sqlalchemy import select

app = FastAPI()
```

## Get Post(s)

### Get All Posts

```python
@app.get("/posts")
def get_posts(db: Session = Depends(get_db)):
    posts = db.execute(select(Post)).scalars().all()
    return posts
```

!!! Code Explanation:

1. **`db: Session = Depends(get_db)`**:
   - A dependency injection to get a SQLAlchemy session.
   - Each request gets a unique session that is closed after the request.

2. **`db.execute(select(Post))`**:
   - Uses the new SQLAlchemy 2.0 syntax for querying data.
   - The `select()` function replaces `.query()` to define the query for the `Post` model.

3. **`.scalars().all()`**:
   - Retrieves all the rows as scalar values (individual ORM objects).

### Get a Post

- To get a single post, we have to ensure that the post with that ID exists before retrieving it.
- The helper function below ensures that we pass the post ID and database session to check if the post exists. If not, it raises an error.

```python
def get_post_or_404(post_id: int, db: Session):
    post = db.get(Post, post_id)
    if post is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Post with id {post_id} was not found."
        )
    return post
```

- Now, to get a single post, we use the helper function:

```python
@app.get("/posts/{post_id}")
def get_post(post_id: int, db: Session = Depends(get_db)):
    return {"data": get_post_or_404(post_id, db)}
```

!!! Code Explanation:

- The `get_post_or_404` function encapsulates the logic for fetching a post and handling a missing post error.
- This prevents code duplication and keeps the route function clean.

## Create Posts

```python
@app.post("/posts", status_code=status.HTTP_201_CREATED)
def create_post(post: PostCreate, db: Session = Depends(get_db)):
    new_post = Post(**post.model_dump())
    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

!!! Code Explanation:

1. **`Post(**post.model_dump())`**:
   - Converts the request body (`post`) into a dictionary and unpacks it into the `Post` model.
   - This eliminates the need to manually map fields like `title`, `content`, and `published`.
   - Simplifies the code significantly, especially when dealing with models that have many fields.

2. **`db.add(new_post)`**:
   - Stages the new object for insertion into the database.

3. **`db.commit()`**:
   - Commits all staged changes to the database.

4. **`db.refresh(new_post)`**:
   - Updates the object with any additional fields generated by the database (e.g., ID, created_at).
   - SQLAlchemy does not immediately retrieve auto-generated fields (like IDs).
   - The `refresh()` method ensures the `new_post` object reflects the database state after the commit.

## Update a Post

```python
@app.put("/posts/{post_id}")
def update_post(post_id: int, post: PostSchema = Body(...), db: Session = Depends(get_db)):
    existing_post = get_post_or_404(post_id, db)

    for key, value in post.model_dump(exclude_unset=True).items():
        setattr(existing_post, key, value)

    db.commit()
    db.refresh(existing_post)
    return existing_post
```

!!! Code Explanation:

1. **`get_post_or_404(post_id, db)`**:
   - Ensures that the post exists before attempting to update it.

2. **`post.model_dump(exclude_unset=True)`**:
   - Extracts only the fields provided in the update request, leaving others unchanged.

3. **`setattr(existing_post, key, value)`**:
   - Dynamically updates the fields of the post object.

4. **`db.commit()` and `db.refresh(existing_post)`**:
   - Saves the changes and ensures the updated object is synchronized with the database.

## Delete a Post

```python
@app.delete("/posts/{post_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(post_id: int, db: Session = Depends(get_db)):
    existing_post = get_post_or_404(post_id, db)
    db.delete(existing_post)
    db.commit()
    return Response(status_code=status.HTTP_204_NO_CONTENT)
```

!!! Code Explanation:

1. **`get_post_or_404(post_id, db)`**:
   - Ensures the post exists before attempting deletion.

2. **`db.delete(existing_post)`**:
   - Marks the object for deletion.

3. **`db.commit()`**:
   - Executes the delete operation in the database.

4. **Response(status_code=status.HTTP_204_NO_CONTENT)**:
   - Returns a success response with no content, indicating the post was successfully deleted.

## Defining a Response Models with Pydantic

- We can also define Pydantic models (or schema models) to shape API responses precisely.
- The primary goal is to avoid exposing unnecessary or sensitive data, such as passwords, when sending responses to users.

### Key Concepts

1. **Response Models**:
   - Pydantic models allow us to control the fields returned to users.
   - By explicitly specifying the fields in response models, we ensure only relevant data is shared.

2. **Removing the `data` Wrapper**:
   - Earlier responses included a `"data"` wrapper around the returned content, which was unnecessary.

   ```python
   @app.post("/posts", status_code=status.HTTP_201_CREATED)
   def create_post(post: PostCreate = Body(...), db: Session = Depends(get_db)):
      # logic goes here
      return {"data": new_post}
   ```

   - By directly returning models, FastAPI can automatically serialize them into JSON responses.

   ```python
   @app.post("/posts", status_code=status.HTTP_201_CREATED)
   def create_post(post: PostCreate = Body(...), db: Session = Depends(get_db)):
      # logic goes here
      return new_post
   ```

3. **Reusing Base Classes**:
   - To avoid duplication, use inheritance. A base class (e.g., `PostBase`) can define common fields, which other models (e.g., `PostResponse`) can extend.

   ```python
   from pydantic import BaseModel

   class PostBase(BaseModel):
    title: str
    content: str
    published: bool = True
    ```

4. **(Optional) ORM Mode**:
   - Pydantic models require data in dictionary format. SQLAlchemy models are not dictionaries, leading to errors.
   - To fix this, enable ORM mode in Pydantic models by adding `class Config` with `orm_mode = True`.

   ```python
   class PostResponse(PostBase):
    id: int
    created_at: datetime

    class Config:
        orm_mode = True
   ```

   - Note that `PostResponse` extends `PostBase` and adds `id` and `created_at` fields for responses.

5. **Tailored Response:**

   - To ensure that users get only the necessary output, the tailored response models are passed as an argument to path operation

   ```python
   # creating post
   @app.post("/posts", status_code=status.HTTP_201_CREATED, response_model=PostResponse)

   # getting multiple posts in a list
   @app.get("/posts", response_model=list[PostResponse])

   # getting a single post
   @app.get("/posts/{post_id}", response_model=PostResponse)

   # updating a post
   @app.put("/posts/{post_id}", response_model=PostResponse)
   ```

### Output Behavior

- Responses return only the fields defined in the Pydantic models.
- Users do not receive sensitive or unnecessary data.
- Example response for creating a post:

  ```json
  {
      "id": 1,
      "title": "Post Title",
      "content": "Post Content",
      "published": true,
      "created_at": "2023-01-01T00:00:00"
  }
  ```
